{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"cardano-node-clients","text":"<p>Channel-driven Haskell clients for Cardano node Ouroboros mini-protocols.</p>"},{"location":"#overview","title":"Overview","text":"<p>This library provides high-level interfaces for communicating with a Cardano node:</p> <ul> <li>Provider -- query UTxOs and protocol parameters</li> <li>Submitter -- submit signed transactions</li> <li>Balance -- iterative fee estimation and transaction balancing</li> </ul> <p>The interfaces are protocol-agnostic records-of-functions. Each transport protocol supplies its own constructor:</p> Protocol Provider Submitter N2C (Unix socket) <code>mkN2CProvider</code> <code>mkN2CSubmitter</code> N2N (TCP) planned planned"},{"location":"#quick-start","title":"Quick start","text":"<pre><code>import Cardano.Node.Client.N2C.Connection\nimport Cardano.Node.Client.N2C.Provider\nimport Cardano.Node.Client.N2C.Submitter\nimport Control.Concurrent.Async (async)\nimport Ouroboros.Network.Magic (NetworkMagic (..))\n\nmain :: IO ()\nmain = do\n    lsqCh  &lt;- newLSQChannel 16\n    ltxsCh &lt;- newLTxSChannel 16\n    -- connect in background\n    _ &lt;- async $\n        runNodeClient\n            (NetworkMagic 764824073)  -- mainnet\n            \"/run/cardano-node/node.socket\"\n            lsqCh\n            ltxsCh\n    let provider  = mkN2CProvider lsqCh\n        submitter = mkN2CSubmitter ltxsCh\n    -- use provider / submitter ...\n    pure ()\n</code></pre>"},{"location":"#build","title":"Build","text":"<pre><code>nix develop -c just build   # compile\nnix develop -c just ci      # format + lint + build\n</code></pre>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/#design","title":"Design","text":"<p>The library separates protocol-agnostic interfaces from protocol-specific implementations.</p> <pre><code>Cardano.Node.Client\n\u251c\u2500\u2500 Types          -- Block, BlockPoint aliases\n\u251c\u2500\u2500 Provider       -- query interface (record-of-functions)\n\u251c\u2500\u2500 Submitter      -- submit interface (record-of-functions)\n\u251c\u2500\u2500 Balance        -- transaction balancing\n\u2514\u2500\u2500 N2C\n    \u251c\u2500\u2500 Types              -- LSQChannel, LTxSChannel\n    \u251c\u2500\u2500 Codecs             -- N2C codec config\n    \u251c\u2500\u2500 Connection         -- multiplexed Unix socket\n    \u251c\u2500\u2500 LocalStateQuery    -- LSQ protocol client\n    \u251c\u2500\u2500 LocalTxSubmission  -- LTxS protocol client\n    \u251c\u2500\u2500 Provider           -- N2C-backed Provider\n    \u2514\u2500\u2500 Submitter          -- N2C-backed Submitter\n</code></pre>"},{"location":"architecture/#channel-driven-protocol-clients","title":"Channel-driven protocol clients","text":"<p>Each mini-protocol client is driven by an STM channel (<code>TBQueue</code>). Callers enqueue a request and block on a <code>TMVar</code> for the result. This decouples request submission from the Ouroboros protocol loop.</p> <pre><code>                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  caller \u2500\u2500req\u2500\u2500\u25ba \u2502   TBQueue     \u2502 \u2500\u2500\u25ba protocol client \u2500\u2500\u25ba node\n  caller \u25c4\u2500res\u2500\u2500  \u2502   TMVar       \u2502 \u25c4\u2500\u2500 protocol client \u25c4\u2500\u2500 node\n                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>The LocalStateQuery client batches queries: it waits for the first query, acquires the volatile tip, drains the queue in a single session, then releases and loops.</p>"},{"location":"architecture/#n2c-connection","title":"N2C connection","text":"<p><code>runNodeClient</code> opens a Unix socket to the Cardano node and multiplexes two mini-protocols:</p> <ul> <li>MiniProtocol 6 -- LocalTxSubmission</li> <li>MiniProtocol 7 -- LocalStateQuery</li> </ul> <p>The connection blocks until closed. Run it in a background thread with <code>async</code>.</p>"},{"location":"architecture/#transaction-balancing","title":"Transaction balancing","text":"<p><code>balanceTx</code> iteratively estimates fees using <code>estimateMinFeeTx</code>, adding fee-paying inputs and a change output. It converges in at most 10 rounds. Only ADA-only inputs are supported; multi-asset coin selection is out of scope.</p>"},{"location":"modules/balance/","title":"Balance","text":"<p>::: {.module} <code>Cardano.Node.Client.Balance</code> :::</p> <p>Iterative fee estimation and transaction balancing for Conway-era transactions.</p> <pre><code>balanceTx\n    :: PParams ConwayEra\n    -&gt; [(TxIn, TxOut ConwayEra)]\n    -&gt; Addr\n    -&gt; Tx ConwayEra\n    -&gt; Either BalanceError (Tx ConwayEra)\n</code></pre>"},{"location":"modules/balance/#algorithm","title":"Algorithm","text":"<ol> <li>Collect all input UTxOs and compute total available ADA</li> <li>Start with fee = 0</li> <li>Build candidate transaction with change output</li> <li>Estimate fee via <code>estimateMinFeeTx</code> (1 key witness assumed)</li> <li>If new fee &gt; current fee, repeat from step 3</li> <li>Converges in at most 10 rounds</li> </ol>"},{"location":"modules/balance/#errors","title":"Errors","text":"<pre><code>data BalanceError\n    = InsufficientFee Coin Coin\n    -- ^ required fee, available ADA\n</code></pre>"},{"location":"modules/balance/#limitations","title":"Limitations","text":"<ul> <li>ADA-only fee inputs (no multi-asset coin selection)</li> <li>Single key witness assumed</li> <li>Callers must construct script inputs separately</li> </ul>"},{"location":"modules/n2c/","title":"N2C (Node-to-Client)","text":"<p>::: {.module} <code>Cardano.Node.Client.N2C.*</code> :::</p> <p>Node-to-Client protocol implementation over Unix sockets.</p>"},{"location":"modules/n2c/#connection","title":"Connection","text":"<pre><code>runNodeClient\n    :: NetworkMagic -&gt; FilePath\n    -&gt; LSQChannel -&gt; LTxSChannel\n    -&gt; IO (Either SomeException ())\n</code></pre> <p>Opens a multiplexed connection with two mini-protocols:</p> <ul> <li>MiniProtocol 6 -- LocalTxSubmission</li> <li>MiniProtocol 7 -- LocalStateQuery</li> </ul> <p>Uses <code>NodeToClientV_20</code> and <code>CardanoNodeToClientVersion16</code>.</p>"},{"location":"modules/n2c/#channels","title":"Channels","text":"<p>Create channels before starting the connection:</p> <pre><code>lsqCh  &lt;- newLSQChannel 16   -- 16-slot query queue\nltxsCh &lt;- newLTxSChannel 16  -- 16-slot submit queue\n</code></pre>"},{"location":"modules/n2c/#localstatequery","title":"LocalStateQuery","text":"<p>The LSQ client batches queries in a single acquired session. Use <code>queryLSQ</code> for direct access:</p> <pre><code>queryLSQ :: LSQChannel -&gt; Query Block result -&gt; IO result\n</code></pre>"},{"location":"modules/n2c/#localtxsubmission","title":"LocalTxSubmission","text":"<p>Use <code>submitTxN2C</code> for low-level submission (takes <code>GenTx Block</code>), or prefer the high-level <code>mkN2CSubmitter</code> which wraps <code>Tx ConwayEra</code> automatically.</p> <pre><code>submitTxN2C :: LTxSChannel -&gt; GenTx Block -&gt; IO (Either (ApplyTxErr Block) ())\n</code></pre>"},{"location":"modules/provider/","title":"Provider","text":"<p>::: {.module} <code>Cardano.Node.Client.Provider</code> :::</p> <p>Protocol-agnostic interface for querying the Cardano blockchain.</p> <pre><code>data Provider m = Provider\n    { queryUTxOs         :: Addr -&gt; m [(TxIn, TxOut ConwayEra)]\n    , queryProtocolParams :: m (PParams ConwayEra)\n    , evaluateTx         :: Tx ConwayEra -&gt; m (EvaluateTxResult ConwayEra)\n    }\n</code></pre>"},{"location":"modules/provider/#fields","title":"Fields","text":"Field Description <code>queryUTxOs</code> Look up UTxOs at an address <code>queryProtocolParams</code> Fetch current protocol parameters <code>evaluateTx</code> Evaluate script execution units for a transaction"},{"location":"modules/provider/#evaluatetx","title":"<code>evaluateTx</code>","text":"<p>Evaluates Plutus script execution units for a fully-built transaction. The implementation resolves all transaction inputs (spending, collateral, and reference) from the node, fetches protocol parameters, system start, and the hard-fork interpreter, then calls the ledger's <code>evalTxExUnits</code> locally.</p> <p>Returns a <code>Map</code> from each script purpose to either a <code>TransactionScriptFailure</code> or the computed <code>ExUnits</code>.</p>"},{"location":"modules/provider/#constructors","title":"Constructors","text":"Function Module Transport <code>mkN2CProvider</code> <code>Cardano.Node.Client.N2C.Provider</code> Unix socket (N2C)"},{"location":"modules/provider/#usage","title":"Usage","text":"<pre><code>import Cardano.Node.Client.N2C.Provider (mkN2CProvider)\n\nlet provider = mkN2CProvider lsqChannel\n\nutxos  &lt;- queryUTxOs provider myAddress\npp     &lt;- queryProtocolParams provider\nexUnits &lt;- evaluateTx provider mySignedTx\n</code></pre>"},{"location":"modules/submitter/","title":"Submitter","text":"<p>::: {.module} <code>Cardano.Node.Client.Submitter</code> :::</p> <p>Protocol-agnostic interface for submitting signed transactions.</p> <pre><code>data SubmitResult\n    = Submitted TxId\n    | Rejected ByteString\n\nnewtype Submitter m = Submitter\n    { submitTx :: Tx ConwayEra -&gt; m SubmitResult\n    }\n</code></pre>"},{"location":"modules/submitter/#constructors","title":"Constructors","text":"Function Module Transport <code>mkN2CSubmitter</code> <code>Cardano.Node.Client.N2C.Submitter</code> Unix socket (N2C)"},{"location":"modules/submitter/#usage","title":"Usage","text":"<pre><code>import Cardano.Node.Client.N2C.Submitter (mkN2CSubmitter)\n\nlet submitter = mkN2CSubmitter ltxsChannel\n\nresult &lt;- submitTx submitter signedTx\ncase result of\n    Submitted txId -&gt; putStrLn $ \"OK: \" &lt;&gt; show txId\n    Rejected reason -&gt; putStrLn $ \"FAIL: \" &lt;&gt; show reason\n</code></pre>"}]}